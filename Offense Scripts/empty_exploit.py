#!/usr/bin/python

import struct
import socket
import sys
import time
import binascii
import os
import math
import md5
import re
import hashlib
import telnetlib
import base64
import random
import string

alphanum = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'

class brute(object):
   def __init__(self, chars, n):
      self.chars = chars
      self.n = n
      self.state = [0 for i in range(n)]
      self.atend = False
   
   def __iter__(self):
      return self
   
   def next(self):
      if self.atend:
         raise StopIteration()
      res = [self.chars[self.state[i]] for i in range(self.n)]
      for i in range(self.n):
         self.state[i] += 1;
         if self.state[i] == len(self.chars):
            self.state[i] = 0
         else:
            return ''.join(res)
      self.atend = True
      return ''.join(res)

def rnd_string(sz):
   res = ''
   for i in xrange(sz):
      res += alphanum[random.randrange(0, len(alphanum))]
   return res

def p(f, *args):
   return struct.pack(f, *args)

p32 = lambda x: p("<I", x)
p64 = lambda x: p("<Q", x)

def u(f, v):
   return struct.unpack(f, v)

u32 = lambda x: u("<I", x.ljust(4, '\x00')[:4])[0]
u64 = lambda x: u("<Q", x.ljust(8, '\x00')[:8])[0]

def hx(s):
   return binascii.hexlify(s)
   
def ux(s):
   return binascii.unhexlify(s)

def readUntil(s, content, echo = True):
   x = ""
   while True:
      y = s.recv(1)
      if not y:
         return False
      x += y
      for v in content:
         if x.endswith(v):
            if echo:
               sys.stderr.write(x)
            return x

def ru(s, txt):
   return readUntil(s, [txt])

def rl(s):
   return ru(s, '\n')

def interact(s):
   t = telnetlib.Telnet()                                                            
   t.sock = s                                                                        
   t.interact() 

tgtport = 1234

if len(sys.argv) >= 2:
   tgthost = sys.argv[1]
   if len(sys.argv) >= 3:
      tgtport = int(sys.argv[2])
elif 'TARGET_HOST' in os.environ:
   tgthost = os.environ['TARGET_HOST']
   #tgtport in this case needs to be set above
else:
   print "Missing required parameters: <target ip> <target port>"
   print "These must be supplied as argv[1] and argv[2] or"
   print "by setting the TARGET_HOST environment variable"
   sys.exit(1)

flag = None

target = (tgthost, tgtport)

s = socket.socket()
s.connect(target)


#DO THE FUN STUFF HERE

#if you have anything you want to define that differs between
#local and remote targets you might do it here
#should probably tie local to a command line argument and get real
#about argument parsing
local = True
if local:
   lsm_offset = 0
   binsh_offset = 0
else:
   lsm_offset = 0
   binsh_offset = 0




interact(s)

s.close()

if flag:
   if 'FLAG_HOST' in os.environ:
      flghost = os.environ['FLAG_HOST']
      flgport = os.environ['FLAG_PORT']
      fsock = socket.socket()
      fsock.connect((flghost, flgport))
      fsock.send(flag)
      fsock.close()
   elif 'FLAG_FILE' in os.environ:
      flgfile = os.environ['FLAG_FILE']
      ffile = open(flgfile, 'w')
      ffile.write(flag)
      ffile.close()
   else:
      sys.stdout.write(flag)
